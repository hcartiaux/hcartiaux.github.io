<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		

		<title>Turing complete - self documentation</title>

		
		<link rel="stylesheet" href="https://hcartiaux.github.io/css/colors-dark.min.c55872c93a117ae390d387b98ba5b7afff286ffdcd1d53581682c96415ced087.css">

		
	</head>
	<body>
		<header id="header">
			<h1><a href="https://hcartiaux.github.io/">My sysadmin notes</a></h1>
			<p>Btw I use arch</p>
		</header>

		<div id="page">
			<div id="sidebar">
				<nav>
	
</nav>

			</div>

			<div id="content">
				
	<article class="post">
		<h1><a href="https://hcartiaux.github.io/posts/2024-04-17-turing-complete-documentation/">Turing complete - self documentation</a> </h1>

		<div class="post-content"><p>This is my documentation for <a href="https://turingcomplete.game/profile/38047">my own game</a> of <a href="https://turingcomplete.game/">Turing Complete</a>.
Turing Complete purpose is to guide you through the implementation of a simple CPU, from the first logical gate to your assembly language definition.</p>
<p>This page is mostly intended to myself as a reminder.
This is very far from the best design and solutions, but it&rsquo;s the best I could do in a reasonable time :)</p>
<h2 id="schematic">Schematic</h2>
<p><a href="turing_complete_annotated.png"><img src="turing_complete_annotated.png" alt="My own computer in Turing Complete"></a></p>
<p><a href="turing_complete.png">Raw version, non annnotated</a></p>
<h2 id="instructions-set">Instructions set</h2>
<h3 id="syntax">Syntax</h3>
<p>Instruction <code>&lt;op code&gt; &lt;arg1&gt; &lt;arg2&gt; &lt;dest&gt;</code></p>
<p><code>&lt;arg1&gt;</code> and <code>&lt;arg2&gt;</code> can be set to an immediate value with bitwise OR on the opcode:</p>
<ul>
<li>for <code>arg1</code>, <code>&lt;op code&gt;|128</code></li>
<li>for <code>arg2</code>, <code>&lt;op code&gt;|64</code></li>
</ul>
<h3 id="table">Table</h3>
<table>
<thead>
<tr>
<th>OP Code</th>
<th>Assembly instruction</th>
<th>Parameters</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>add</td>
<td></td>
<td><code>&lt;arg1&gt;</code> + <code>&lt;arg2&gt;</code> in register <code>&lt;dest&gt;</code></td>
</tr>
<tr>
<td>1</td>
<td>sub</td>
<td></td>
<td><code>&lt;arg1&gt;</code> - <code>&lt;arg2&gt;</code> in register <code>&lt;dest&gt;</code></td>
</tr>
<tr>
<td>2</td>
<td>and</td>
<td></td>
<td><code>&lt;arg1&gt;</code> AND <code>&lt;arg2&gt;</code> in register <code>&lt;dest&gt;</code></td>
</tr>
<tr>
<td>3</td>
<td>or</td>
<td></td>
<td><code>&lt;arg1&gt;</code> OR <code>&lt;arg2&gt;</code> in register <code>&lt;dest&gt;</code></td>
</tr>
<tr>
<td>4</td>
<td>not</td>
<td></td>
<td><code>&lt;arg1&gt;</code> NOT <code>&lt;arg2&gt;</code> in register <code>&lt;dest&gt;</code></td>
</tr>
<tr>
<td>5</td>
<td>xor</td>
<td></td>
<td><code>&lt;arg1&gt;</code> XOR <code>&lt;arg2&gt;</code> in register <code>&lt;dest&gt;</code></td>
</tr>
<tr>
<td>6</td>
<td>shift_right</td>
<td></td>
<td>shift right <code>&lt;arg1&gt;</code> by <code>&lt;arg2&gt;</code> in register <code>&lt;dest&gt;</code></td>
</tr>
<tr>
<td>7</td>
<td>shift_left</td>
<td></td>
<td>shift left <code>&lt;arg1&gt;</code> by <code>&lt;arg2&gt;</code> in register <code>&lt;dest&gt;</code></td>
</tr>
<tr>
<td>8</td>
<td>ram_input</td>
<td><code>&lt;src&gt; &lt;unused&gt; &lt;unused&gt;</code></td>
<td>Store <code>&lt;arg1&gt;</code> in RAM at the address stored in R5</td>
</tr>
<tr>
<td>9</td>
<td>ram_output</td>
<td><code>&lt;unused&gt; &lt;unused&gt; &lt;dest&gt;</code></td>
<td>Copy to <code>&lt;dest&gt;</code> the value stored at the RAM address stored in R5</td>
</tr>
<tr>
<td>10</td>
<td>mul</td>
<td></td>
<td><code>&lt;arg1&gt;</code> * <code>&lt;arg2&gt;</code> in register <code>&lt;dest&gt;</code></td>
</tr>
<tr>
<td>11</td>
<td>push</td>
<td><code>&lt;src&gt; &lt;unused&gt; &lt;unused&gt;</code></td>
<td>Push <code>&lt;arg1&gt;</code> to the stack</td>
</tr>
<tr>
<td>12</td>
<td>pop</td>
<td><code>&lt;unused&gt; &lt;unused&gt; &lt;dest&gt;</code></td>
<td>Pop the stack into <code>&lt;dest&gt;</code></td>
</tr>
<tr>
<td>13</td>
<td>call</td>
<td><code>&lt;unused&gt; &lt;unused&gt; &lt;dest&gt;</code></td>
<td>push PC+4 to the stack and set the PC to <code>dest</code></td>
</tr>
<tr>
<td>14</td>
<td>ret</td>
<td><code>&lt;unused&gt; &lt;unused&gt; &lt;unused&gt;</code></td>
<td>pop the stack to the PC</td>
</tr>
<tr>
<td>32</td>
<td>eq</td>
<td></td>
<td>set PC to <code>&lt;dest&gt;</code> if <code>&lt;arg1&gt;</code> = <code>&lt;arg2&gt;</code></td>
</tr>
<tr>
<td>33</td>
<td>neq</td>
<td></td>
<td>set PC to <code>&lt;dest&gt;</code> if <code>&lt;arg1&gt;</code> != <code>&lt;arg2&gt;</code></td>
</tr>
<tr>
<td>34</td>
<td>lt</td>
<td></td>
<td>set PC to <code>&lt;dest&gt;</code> if <code>&lt;arg1&gt;</code> &lt; <code>&lt;arg2&gt;</code></td>
</tr>
<tr>
<td>35</td>
<td>le</td>
<td></td>
<td>set PC to <code>&lt;dest&gt;</code> if <code>&lt;arg1&gt;</code> &lt;= <code>&lt;arg2&gt;</code></td>
</tr>
<tr>
<td>36</td>
<td>gt</td>
<td></td>
<td>set PC to <code>&lt;dest&gt;</code> if <code>&lt;arg1&gt;</code> &gt; <code>&lt;arg2&gt;</code></td>
</tr>
<tr>
<td>37</td>
<td>ge</td>
<td></td>
<td>set PC to <code>&lt;dest&gt;</code> if <code>&lt;arg1&gt;</code> &gt;= <code>&lt;arg2&gt;</code></td>
</tr>
</tbody>
</table>
<h2 id="addresses">Addresses</h2>
<table>
<thead>
<tr>
<th>Register address</th>
<th>Register name</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Register 0</td>
</tr>
<tr>
<td>1</td>
<td>Register 1</td>
</tr>
<tr>
<td>2</td>
<td>Register 2</td>
</tr>
<tr>
<td>3</td>
<td>Register 3</td>
</tr>
<tr>
<td>4</td>
<td>Register 4</td>
</tr>
<tr>
<td>5</td>
<td>Register 5 - ram pointer</td>
</tr>
<tr>
<td>6</td>
<td>Program Counter (PC)</td>
</tr>
<tr>
<td>7</td>
<td>Input/Output</td>
</tr>
</tbody>
</table>
<h2 id="solution-of-the-level-unseen-fruit">Solution of the level <code>unseen fruit</code></h2>
<pre tabindex="0"><code># Constants definitions for readability
const R0 0
const R1 1
const R2 2
const R3 3
const R4 4

const RAM_PNTR 5
const PROGRAM_CNTR 6
const I_O 7

const _ 0 #UNUSED PARAM

const COUNTER 1

# Go to conveyor belt
add|64|128 2 0 I_O
add|64|128 1 0 I_O
add|64|128 2 0 I_O
add|64|128 1 0 I_O
add|64|128 1 0 I_O
add|64|128 1 0 I_O
add|64|128 1 0 I_O
add|64|128 2 0 I_O
add|64|128 1 0 I_O
add|64|128 0 0 I_O
add|64|128 1 0 I_O


label main_loop_begin
# copy input in R0
add|64|128 3 0 I_O
add|64 I_O 0 R0
# if input = 92, wait for a fruit
cond_eq|64 R0 92 main_loop_begin
# if input != 92, call function check
call _ _ check
jump _ _ main_loop_begin
label main_loop_end

jump _ _ end

# function check - # check if fruit has already been seen
label check
add|64|128 0 0 RAM_PNTR
label check_loop_begin
# load ram
ram_output _ _ R2
add|128 1 RAM_PNTR RAM_PNTR
cond_eq R0 R2 check_push
cond_gt RAM_PNTR COUNTER check_store
jump _ _ check_loop_begin

# function check_store
# if input number is not in memory, store the number
label check_store
call _ _ store
jump _ _ check_loop_end

# function check_push
# else, push the button
label check_push
call _ _ push
jump _ _ check_loop_end
label check_loop_end
cond_le R2 COUNTER check_loop_begin
label check_end
ret

# function store
# Append a new value in RAM
label store
add|128 1 COUNTER COUNTER
add|128 0 COUNTER RAM_PNTR
ram_input R0 _ _
ret

# Push the button
label push
add|64|128 2 0 I_O
add|64|128 4 0 I_O
add|64|128 0 0 I_O
ret

label end
</code></pre><h2 id="solution-of-the-level-delicious-order">Solution of the level <code>delicious order</code></h2>
<p>The program works in 3 steps:</p>
<ol>
<li>loads all the values from I_O and store them in memory</li>
<li>performs a bubble sort, suboptimal - O(nÂ²) - but easy and readable</li>
<li>Output the sorted data</li>
</ol>
<pre tabindex="0"><code>const R0 0
const R1 1
const R2 2
const R3 3
const R4 4

const RAM_PNTR 5
const PROGRAM_CNTR 6
const I_O 7

const _ 0

const array_size 15

# Init Registers to 0
add|64|128 0 0 R0
add|64|128 0 0 R1
add|64|128 0 0 R2
add|64|128 0 0 R3
add|64|128 0 0 R4
add|64|128 0 0 RAM_PNTR

# Load in memory
label load
push I_O _ _
add|64 RAM_PNTR 1 RAM_PNTR
cond_le|64 RAM_PNTR array_size load
add|64|128 _ _ RAM_PNTR # set to 0
label copy_mem
pop _ _ R0
ram_input R0 _ _
add|64 RAM_PNTR 1 RAM_PNTR
cond_le|64 RAM_PNTR array_size copy_mem

# Init Registers to 0
add|64|128 0 0 R0
add|64|128 0 0 RAM_PNTR

const I R0
const MAX_I array_size
const J R1
const MAX_J R2

label main_loop

sub|128 MAX_I I MAX_J

label inner_loop

# Compare and swap
# RAM_PNTR &lt;- J
add J 0 RAM_PNTR
# R3 &lt;- RAM
ram_output  _ _ R3
# RAM_PNTR &lt;- J+1
add|64 RAM_PNTR 1 RAM_PNTR
# R4 &lt;- RAM
ram_output  _ _ R4
# if R3 &gt; R4, Swap R3-R4
cond_le R3 R4 no_swap
#  Push R3 to RAM_PNTR[J+1]
ram_input R3 _ _
#  Push R4 to RAM_PNTR[J]
sub|64 RAM_PNTR 1 RAM_PNTR
ram_input R4 _ _
label no_swap

# end inner_loop

add|64 J 1 J
cond_lt J MAX_J inner_loop
add|64|128 0 0 J

# end main_loop
add|64 I 1 I
cond_lt|64 I MAX_I main_loop



# Unload
add|64|128 0 0 RAM_PNTR
label unload
add|64 RAM_PNTR 1 RAM_PNTR
ram_output _ _ I_O
cond_le|64 RAM_PNTR array_size unload
</code></pre></div>

		<p class="meta">Posted on <span class="postdate">17. April 2024</span></p>
	</article>

			</div>

			<footer id="footer">
				<p class="copyright">
					
						CC BY-SA 4.0
					
				</p>
			</footer>
		</div>

		
	</body>
</html>
